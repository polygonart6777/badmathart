<aside class="notes">
    Slide 300 for 500 pixels shows cool image.

    Times where we get these Moire effects of some interference happening.
    Other times where it just looks noisy.

    Talk about the last three points!
    1. Getting started
    2. Freedom
    3. curiosity

</aside>
<style>


  .canvas-cat {
    border: 1px solid #ccc;
    image-rendering: pixelated;
    width: 450px;
    height: 450px;
    max-width:450px;
    max-height:450px;
  }

  button {
    padding: 10px 20px;
    margin: 5px;
    font-size: 16px;
  }

  input[type="file"] {
    margin: 10px;
  }
</style>

<input type="file" id="imageInput" accept="image/*" />

<select id="pictureSizeSelect" onchange="updateCanvasSize()">
  <option value="14">14x14</option>
  <option value="15">15x15</option>
  <option value="16" selected>16x16</option>
  <option value="161">161x161</option>
  <option value="500">500x500</option>
</select>
<br /><br />

<canvas class="canvas-cat" id="canvas-cat" width="16" height="16"></canvas>
<br />

<button onclick="toggleAnimation()">Animate</button>
<button onclick="stepBack()">← Back</button>
<button onclick="stepForward()">Forward →</button>
<button onclick="reset()">Reset</button>

<p>Iterations: <span id="count">0</span></p>

<script>
  const canvas = document.getElementById("canvas-cat");
  const ctx = canvas.getContext("2d");
  let originalData2 = null;
  let currentData = null;
  let iterations = 0;
  let currentSize2 = 16;
  let isAnimating = false;
  let animationId = null;
  let transformHistory = [];

  document
    .getElementById("imageInput")
    .addEventListener("change", function (e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (e) {
        const img = new Image();
        img.onload = function () {
          ctx.drawImage(img, 0, 0, currentSize2, currentSize2);
          originalData2 = ctx.getImageData(0, 0, currentSize2, currentSize2);
          currentData = ctx.getImageData(0, 0, currentSize2, currentSize2);
          iterations = 0;
          transformHistory = [
            new ImageData(
              new Uint8ClampedArray(currentData.data),
              currentSize2,
              currentSize2,
            ),
          ];
          updateCount();
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    });

  function transform() {
    if (!currentData) return;

    const data = currentData.data;
    const newData = new Uint8ClampedArray(data.length);

    for (let y = 0; y < currentSize2; y++) {
      for (let x = 0; x < currentSize2; x++) {
        const newX = (x + y) % currentSize2;
        const newY = (x + 0 * y) % currentSize2;

        const oldIndex = (y * currentSize2 + x) * 4;
        const newIndex = (newY * currentSize2 + newX) * 4;

        for (let i = 0; i < 4; i++) {
          newData[newIndex + i] = data[oldIndex + i];
        }
      }
    }

    currentData = new ImageData(newData, currentSize2, currentSize2);
    ctx.putImageData(currentData, 0, 0);
    iterations++;

    transformHistory = transformHistory.slice(0, iterations);
    transformHistory.push(
      new ImageData(
        new Uint8ClampedArray(currentData.data),
        currentSize2,
        currentSize2,
      ),
    );

    updateCount();
  }

  function stepForward() {
    if (transformHistory.length > iterations + 1) {
      iterations++;
      currentData = new ImageData(
        new Uint8ClampedArray(transformHistory[iterations].data),
        currentSize2,
        currentSize2,
      );
      ctx.putImageData(currentData, 0, 0);
      updateCount();
    } else {
      transform();
    }
  }

  function stepBack() {
    if (iterations > 0) {
      iterations--;
      currentData = new ImageData(
        new Uint8ClampedArray(transformHistory[iterations].data),
        currentSize2,
        currentSize2,
      );
      ctx.putImageData(currentData, 0, 0);
      updateCount();
    }
  }

  function reset() {
    if (originalData2) {
      currentData = new ImageData(
        new Uint8ClampedArray(originalData2.data),
        currentSize2,
        currentSize2,
      );
      ctx.putImageData(currentData, 0, 0);
      iterations = 0;
      transformHistory = [
        new ImageData(
          new Uint8ClampedArray(currentData.data),
          currentSize2,
          currentSize2,
        ),
      ];
      updateCount();
    }
  }

  function loadDefaultImage() {
    const img = new Image();
    img.onload = function () {
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, currentSize2, currentSize2);
      ctx.drawImage(img, 0, 0, currentSize2, currentSize2);

      originalData2 = ctx.getImageData(0, 0, currentSize2, currentSize2);
      currentData = ctx.getImageData(0, 0, currentSize2, currentSize2);
      iterations = 0;
      transformHistory = [
        new ImageData(
          new Uint8ClampedArray(currentData.data),
          currentSize2,
          currentSize2,
        ),
      ];
      updateCount();
    };

    if (currentSize2 == 14) {
      img.src = "src/assets/14by14cat.png";
    }

    if (currentSize2 == 15) {
      img.src = "src/assets/15by15cat.png";
    }

    if (currentSize2 == 16) {
      img.src = "src/assets/16by16cat.png";
    }

    if (currentSize2 == 161) {
      img.src = "src/assets/161pixelcat.png";
    }

    if (currentSize2 == 500) {
      img.src = "src/assets/500pixelcat.png";
    }

    if (currentSize2 == 1024) {
      img.src = "src/assets/1024pixelcat.png";
    }
  }

  function updateCanvasSize() {
    currentSize2 = parseInt(document.getElementById("pictureSizeSelect").value);
    canvas.width = currentSize2;
    canvas.height = currentSize2;
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, currentSize2, currentSize2);

    // Reset data
    originalData2 = null;
    currentData = null;
    iterations = 0;
    transformHistory = [];
    updateCount();

    // Stop animation if running
    if (isAnimating) {
      toggleAnimation();
    }
    console.log(currentSize);
    loadDefaultImage();
  }

  function toggleAnimation() {
    if (isAnimating) {
      // Stop animation
      isAnimating = false;
      clearInterval(animationId);
      document.querySelector(
        'button[onclick="toggleAnimation()"]',
      ).textContent = "Animate";
    } else {
      // Start animation
      if (!currentData) return;

      isAnimating = true;
      document.querySelector(
        'button[onclick="toggleAnimation()"]',
      ).textContent = "Stop";

      animationId = setInterval(() => {
        stepForward();
      }, 300); // Transform every 300ms
    }
  }

  function updateCount() {
    document.getElementById("count").textContent = iterations;
  }

  // Load checkerboard on start
  loadDefaultImage();
</script>

<aside class="notes">(1 min) Need to get to 300.</aside>
